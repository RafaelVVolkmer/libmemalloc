<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>libmemalloc: src/libmemalloc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="coverage-pill.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/jothepro/doxygen-awesome-css" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libmemalloc.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmemalloc
   &#160;<span id="projectnumber">v3.0.00</span>
   </div>
   <div id="projectbrief">Modern Memory Allocator</div>
  </td>
 </tr>
 </tbody>
</table>
<div id="theme-selection">
 <label for="theme-select">Theme:</label>
 <select id="theme-select">
  <option value="theme-default">Default</option>
  <option value="theme-round">Round</option>
  <option value="theme-robot">Robot</option>
 </select>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('libmemalloc_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">libmemalloc.c File Reference<div class="ingroups"><a class="el" href="group___libmemalloc.html">Libmemalloc</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Core memory management components for libmemalloc.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;sys/resource.h&gt;</code><br />
<code>#include &quot;<a class="el" href="libmemalloc_8h_source.html">libmemalloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logs_8h_source.html">logs.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for libmemalloc.c:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 --></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__header__t.html">block_header_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the header for a memory block.  <a href="structblock__header__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__arena__t.html">mem_arena_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a memory arena with its own free lists.  <a href="structmem__arena__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmap__t.html">mmap_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks memory-mapped regions for large allocations.  <a href="structmmap__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgc__thread__t.html">gc_thread_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orchestrates the background mark-and-sweep garbage collector.  <a href="structgc__thread__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages dynamic memory allocation.  <a href="structmem__allocator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0b87e0d3bf5853bcbb0b66a7c48fdc05" id="r_a0b87e0d3bf5853bcbb0b66a7c48fdc05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a0b87e0d3bf5853bcbb0b66a7c48fdc05">LOG_LEVEL</a>&#160;&#160;&#160;<a class="el" href="group___logs.html#gga98121d38a8cf3daf5246a349f912ca1da69dacb1837e1e37c6ed34cc2ee1d8848">LOG_LEVEL_NONE</a></td></tr>
<tr class="memdesc:a0b87e0d3bf5853bcbb0b66a7c48fdc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging verbosity threshold for this module.  <br /></td></tr>
<tr class="separator:a0b87e0d3bf5853bcbb0b66a7c48fdc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acceb8a32aeb665817bcac0ae976c3e" id="r_a8acceb8a32aeb665817bcac0ae976c3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a8acceb8a32aeb665817bcac0ae976c3e">DEFAULT_NUM_BINS</a>&#160;&#160;&#160;(uint8_t)(10U)</td></tr>
<tr class="memdesc:a8acceb8a32aeb665817bcac0ae976c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of size classes (bins) for free lists.  <br /></td></tr>
<tr class="separator:a8acceb8a32aeb665817bcac0ae976c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89f60b07247176687889ade776c8e10" id="r_af89f60b07247176687889ade776c8e10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>&#160;&#160;&#160;(uint8_t)(64U)</td></tr>
<tr class="memdesc:af89f60b07247176687889ade776c8e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the CPU cache line in bytes.  <br /></td></tr>
<tr class="separator:af89f60b07247176687889ade776c8e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddd2aeacc155dcd57ad9f7ed7199d9f" id="r_a2ddd2aeacc155dcd57ad9f7ed7199d9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a2ddd2aeacc155dcd57ad9f7ed7199d9f">BYTES_PER_CLASS</a>&#160;&#160;&#160;(uint8_t)(128U)</td></tr>
<tr class="memdesc:a2ddd2aeacc155dcd57ad9f7ed7199d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed byte allocation per classification unit.  <br /></td></tr>
<tr class="separator:a2ddd2aeacc155dcd57ad9f7ed7199d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2911160c515036ceb8c7470a05583ae0" id="r_a2911160c515036ceb8c7470a05583ae0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a2911160c515036ceb8c7470a05583ae0">MMAP_THRESHOLD</a>&#160;&#160;&#160;(size_t)(128U * 1024U)</td></tr>
<tr class="memdesc:a2911160c515036ceb8c7470a05583ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold size for using mmap-based allocation.  <br /></td></tr>
<tr class="separator:a2911160c515036ceb8c7470a05583ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f29ba54415975a2fa23e276fdf8a0f" id="r_ac1f29ba54415975a2fa23e276fdf8a0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ac1f29ba54415975a2fa23e276fdf8a0f">MIN_BLOCK_SIZE</a>&#160;&#160;&#160;(size_t)(sizeof(<a class="el" href="structblock__header__t.html">block_header_t</a>) + ARCH_ALIGNMENT)</td></tr>
<tr class="memdesc:ac1f29ba54415975a2fa23e276fdf8a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the minimum memory block size.  <br /></td></tr>
<tr class="separator:ac1f29ba54415975a2fa23e276fdf8a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c92840d7afc957a6424b6dc3cc089c" id="r_a52c92840d7afc957a6424b6dc3cc089c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a52c92840d7afc957a6424b6dc3cc089c">NR_OBJS</a>&#160;&#160;&#160;(uint16_t)(1000U)</td></tr>
<tr class="memdesc:a52c92840d7afc957a6424b6dc3cc089c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations used to scale GC sleep duration.  <br /></td></tr>
<tr class="separator:a52c92840d7afc957a6424b6dc3cc089c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d054d3a536794b662ab33075d4b9fc6" id="r_a7d054d3a536794b662ab33075d4b9fc6"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a7d054d3a536794b662ab33075d4b9fc6">find_fn_t</a>) (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const, const size_t, <a class="el" href="structblock__header__t.html">block_header_t</a> **)</td></tr>
<tr class="memdesc:a7d054d3a536794b662ab33075d4b9fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for functions that locate a suitable free block.  <br /></td></tr>
<tr class="separator:a7d054d3a536794b662ab33075d4b9fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5805f4c67ac5fe3b63f8e26041ee0aa" id="r_ae5805f4c67ac5fe3b63f8e26041ee0aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ae5805f4c67ac5fe3b63f8e26041ee0aa">MEM_sbrk</a> (const intptr_t increment)</td></tr>
<tr class="memdesc:ae5805f4c67ac5fe3b63f8e26041ee0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes sbrk-like behavior by moving the program break.  <br /></td></tr>
<tr class="separator:ae5805f4c67ac5fe3b63f8e26041ee0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3c776f36dbcd4df3f257d425d5c16" id="r_afce3c776f36dbcd4df3f257d425d5c16"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#afce3c776f36dbcd4df3f257d425d5c16">MEM_getSizeClass</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size)</td></tr>
<tr class="memdesc:afce3c776f36dbcd4df3f257d425d5c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the size class index for a requested memory size.  <br /></td></tr>
<tr class="separator:afce3c776f36dbcd4df3f257d425d5c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb9992270df4add51303b37ef81a93" id="r_ae1eb9992270df4add51303b37ef81a93"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ae1eb9992270df4add51303b37ef81a93">MEM_allocatorInit</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator)</td></tr>
<tr class="memdesc:ae1eb9992270df4add51303b37ef81a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the memory allocator and its internal structures.  <br /></td></tr>
<tr class="separator:ae1eb9992270df4add51303b37ef81a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a9b9d50b0108e6dc6571e30ad99c2" id="r_ac20a9b9d50b0108e6dc6571e30ad99c2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ac20a9b9d50b0108e6dc6571e30ad99c2">MEM_validateBlock</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, <a class="el" href="structblock__header__t.html">block_header_t</a> *const block)</td></tr>
<tr class="memdesc:ac20a9b9d50b0108e6dc6571e30ad99c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the integrity and boundaries of a memory block.  <br /></td></tr>
<tr class="separator:ac20a9b9d50b0108e6dc6571e30ad99c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d23c9024583a7682a5857f59523d6e" id="r_ae5d23c9024583a7682a5857f59523d6e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ae5d23c9024583a7682a5857f59523d6e">MEM_insertFreeBlock</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, <a class="el" href="structblock__header__t.html">block_header_t</a> *const block)</td></tr>
<tr class="memdesc:ae5d23c9024583a7682a5857f59523d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a block into the appropriate free list based on its size.  <br /></td></tr>
<tr class="separator:ae5d23c9024583a7682a5857f59523d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec011b3d73b77babe83930fa7200f0" id="r_a12ec011b3d73b77babe83930fa7200f0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a12ec011b3d73b77babe83930fa7200f0">MEM_removeFreeBlock</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, <a class="el" href="structblock__header__t.html">block_header_t</a> *const block)</td></tr>
<tr class="memdesc:a12ec011b3d73b77babe83930fa7200f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a block from its free list.  <br /></td></tr>
<tr class="separator:a12ec011b3d73b77babe83930fa7200f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c21ef197030ad5077e1438229ecf7b" id="r_ad1c21ef197030ad5077e1438229ecf7b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ad1c21ef197030ad5077e1438229ecf7b">MEM_findFirstFit</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size, <a class="el" href="structblock__header__t.html">block_header_t</a> **fit_block)</td></tr>
<tr class="memdesc:ad1c21ef197030ad5077e1438229ecf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first suitable free memory block in size‐class lists.  <br /></td></tr>
<tr class="separator:ad1c21ef197030ad5077e1438229ecf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5a3d1efacb5148c598825eb0c69708" id="r_a3d5a3d1efacb5148c598825eb0c69708"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a3d5a3d1efacb5148c598825eb0c69708">MEM_findNextFit</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size, <a class="el" href="structblock__header__t.html">block_header_t</a> **fit_block)</td></tr>
<tr class="memdesc:a3d5a3d1efacb5148c598825eb0c69708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the next suitable free memory block using the NEXT_FIT strategy starting from the last allocated position.  <br /></td></tr>
<tr class="separator:a3d5a3d1efacb5148c598825eb0c69708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff4096f96a8b1fb66f4dc035f6e3373" id="r_a0ff4096f96a8b1fb66f4dc035f6e3373"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a0ff4096f96a8b1fb66f4dc035f6e3373">MEM_findBestFit</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size, <a class="el" href="structblock__header__t.html">block_header_t</a> **best_fit)</td></tr>
<tr class="memdesc:a0ff4096f96a8b1fb66f4dc035f6e3373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the smallest suitable free memory block in size‐class lists (BEST_FIT).  <br /></td></tr>
<tr class="separator:a0ff4096f96a8b1fb66f4dc035f6e3373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a027e298e9296c2bbbf6fc80a95afc" id="r_a09a027e298e9296c2bbbf6fc80a95afc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a09a027e298e9296c2bbbf6fc80a95afc">MEM_splitBlock</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, <a class="el" href="structblock__header__t.html">block_header_t</a> *const block, const size_t req_size)</td></tr>
<tr class="memdesc:a09a027e298e9296c2bbbf6fc80a95afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a memory block into allocated and free portions.  <br /></td></tr>
<tr class="separator:a09a027e298e9296c2bbbf6fc80a95afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1829256c0f068782ccab6c9f95c826" id="r_a4b1829256c0f068782ccab6c9f95c826"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a4b1829256c0f068782ccab6c9f95c826">MEM_mergeBlocks</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, <a class="el" href="structblock__header__t.html">block_header_t</a> *block)</td></tr>
<tr class="memdesc:a4b1829256c0f068782ccab6c9f95c826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges adjacent free memory blocks.  <br /></td></tr>
<tr class="separator:a4b1829256c0f068782ccab6c9f95c826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b6c3c4d5bc23814ec213f757471b5" id="r_a429b6c3c4d5bc23814ec213f757471b5"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a429b6c3c4d5bc23814ec213f757471b5">MEM_growUserHeap</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const intptr_t inc)</td></tr>
<tr class="memdesc:a429b6c3c4d5bc23814ec213f757471b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the user heap by a specified increment.  <br /></td></tr>
<tr class="separator:a429b6c3c4d5bc23814ec213f757471b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302a9aebc59213a1fdca5ef62cfd3eef" id="r_a302a9aebc59213a1fdca5ef62cfd3eef"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a302a9aebc59213a1fdca5ef62cfd3eef">MEM_mapAlloc</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t total_size)</td></tr>
<tr class="memdesc:a302a9aebc59213a1fdca5ef62cfd3eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a page-aligned memory region via mmap and registers it in the allocator’s mmap list for later freeing.  <br /></td></tr>
<tr class="separator:a302a9aebc59213a1fdca5ef62cfd3eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b841111a1506abe32e887ca96b883c" id="r_af1b841111a1506abe32e887ca96b883c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#af1b841111a1506abe32e887ca96b883c">MEM_mapFree</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, void *const addr)</td></tr>
<tr class="memdesc:af1b841111a1506abe32e887ca96b883c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps a previously mapped memory region and removes its metadata entry from the allocator’s mmap list.  <br /></td></tr>
<tr class="separator:af1b841111a1506abe32e887ca96b883c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00eae0e01c539537bb9273c5362f9190" id="r_a00eae0e01c539537bb9273c5362f9190"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a00eae0e01c539537bb9273c5362f9190">MEM_allocOp</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size, const char *const file, const int line, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy) <a class="el" href="group___libmemalloc.html#ga958c679d31760dcc44f535b5562037fb">__LIBMEMALLOC_INTERNAL_MALLOC</a></td></tr>
<tr class="memdesc:a00eae0e01c539537bb9273c5362f9190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory using the specified strategy.  <br /></td></tr>
<tr class="separator:a00eae0e01c539537bb9273c5362f9190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c4368d312a9014619535dedfdecda2" id="r_a06c4368d312a9014619535dedfdecda2"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a06c4368d312a9014619535dedfdecda2">MEM_reallocOp</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, void *const ptr, const size_t new_size, const char *const file, const int line, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy) <a class="el" href="group___libmemalloc.html#ga5162cbf57d05fe29d9084f08417325bc">__LIBMEMALLOC_INTERNAL_REALLOC</a></td></tr>
<tr class="memdesc:a06c4368d312a9014619535dedfdecda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory with safety checks.  <br /></td></tr>
<tr class="separator:a06c4368d312a9014619535dedfdecda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a83d9d342786df02d60e0e5f2c75ffc" id="r_a2a83d9d342786df02d60e0e5f2c75ffc"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a2a83d9d342786df02d60e0e5f2c75ffc">MEM_callocOp</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, const size_t size, const char *const file, const int line, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy) <a class="el" href="group___libmemalloc.html#ga958c679d31760dcc44f535b5562037fb">__LIBMEMALLOC_INTERNAL_MALLOC</a></td></tr>
<tr class="memdesc:a2a83d9d342786df02d60e0e5f2c75ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and zero‐initializes memory.  <br /></td></tr>
<tr class="separator:a2a83d9d342786df02d60e0e5f2c75ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd60695c4e1065292ab9af0ec7da5a0" id="r_a8dd60695c4e1065292ab9af0ec7da5a0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a8dd60695c4e1065292ab9af0ec7da5a0">MEM_freeOp</a> (<a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator, void *const ptr, const char *const file, const int line)</td></tr>
<tr class="memdesc:a8dd60695c4e1065292ab9af0ec7da5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases allocated memory back to the heap.  <br /></td></tr>
<tr class="separator:a8dd60695c4e1065292ab9af0ec7da5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd55c30122e42f8dfb40e78861486be" id="r_a0dd55c30122e42f8dfb40e78861486be"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a0dd55c30122e42f8dfb40e78861486be">MEM_stackGrowsDown</a> (void)</td></tr>
<tr class="memdesc:a0dd55c30122e42f8dfb40e78861486be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine at runtime whether the stack grows downward.  <br /></td></tr>
<tr class="separator:a0dd55c30122e42f8dfb40e78861486be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca3438779df1a875f5d8d55f112f2a" id="r_a05ca3438779df1a875f5d8d55f112f2a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a05ca3438779df1a875f5d8d55f112f2a">MEM_stackBounds</a> (const pthread_t id, <a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const allocator)</td></tr>
<tr class="memdesc:a05ca3438779df1a875f5d8d55f112f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query and record the bounding addresses of a thread’s stack.  <br /></td></tr>
<tr class="separator:a05ca3438779df1a875f5d8d55f112f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe1e6a057174df954033f59117b9cde" id="r_gacfe1e6a057174df954033f59117b9cde"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gacfe1e6a057174df954033f59117b9cde">MEM_memset</a> (void *const source, const int value, const size_t size)</td></tr>
<tr class="memdesc:gacfe1e6a057174df954033f59117b9cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a memory block with a specified byte value using optimized operations.  <br /></td></tr>
<tr class="separator:gacfe1e6a057174df954033f59117b9cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f38e83f3601cb880ea1feeb6deaf93" id="r_gaf0f38e83f3601cb880ea1feeb6deaf93"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gaf0f38e83f3601cb880ea1feeb6deaf93">MEM_memcpy</a> (void *const dest, const void *src, const size_t size)</td></tr>
<tr class="memdesc:gaf0f38e83f3601cb880ea1feeb6deaf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a memory block between buffers using optimized operations.  <br /></td></tr>
<tr class="separator:gaf0f38e83f3601cb880ea1feeb6deaf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44952545cf4a9d026d650d6d9d2658f2" id="r_ga44952545cf4a9d026d650d6d9d2658f2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#ga44952545cf4a9d026d650d6d9d2658f2">MEM_allocFirstFit</a> (const size_t size)</td></tr>
<tr class="memdesc:ga44952545cf4a9d026d650d6d9d2658f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory using the FIRST_FIT strategy.  <br /></td></tr>
<tr class="separator:ga44952545cf4a9d026d650d6d9d2658f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39aa1242b547974626068d47aac7e77" id="r_gae39aa1242b547974626068d47aac7e77"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gae39aa1242b547974626068d47aac7e77">MEM_allocBestFit</a> (const size_t size)</td></tr>
<tr class="memdesc:gae39aa1242b547974626068d47aac7e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory using the BEST_FIT strategy.  <br /></td></tr>
<tr class="separator:gae39aa1242b547974626068d47aac7e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e2ace6db68eba981e8be207cd3aed3" id="r_gae4e2ace6db68eba981e8be207cd3aed3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gae4e2ace6db68eba981e8be207cd3aed3">MEM_allocNextFit</a> (const size_t size)</td></tr>
<tr class="memdesc:gae4e2ace6db68eba981e8be207cd3aed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory using the NEXT_FIT strategy.  <br /></td></tr>
<tr class="separator:gae4e2ace6db68eba981e8be207cd3aed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac731edabed78872194a188209e4435fc" id="r_gac731edabed78872194a188209e4435fc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gac731edabed78872194a188209e4435fc">MEM_alloc</a> (const size_t size, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy)</td></tr>
<tr class="memdesc:gac731edabed78872194a188209e4435fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory using the specified strategy.  <br /></td></tr>
<tr class="separator:gac731edabed78872194a188209e4435fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27be8a5fc93952695fd2f8b977c49cb1" id="r_ga27be8a5fc93952695fd2f8b977c49cb1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#ga27be8a5fc93952695fd2f8b977c49cb1">MEM_calloc</a> (const size_t size, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy)</td></tr>
<tr class="memdesc:ga27be8a5fc93952695fd2f8b977c49cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and zero‐initializes memory using the specified strategy.  <br /></td></tr>
<tr class="separator:ga27be8a5fc93952695fd2f8b977c49cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8496139e385d0f5369307ebca30bf17" id="r_gaf8496139e385d0f5369307ebca30bf17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#gaf8496139e385d0f5369307ebca30bf17">MEM_realloc</a> (void *const ptr, const size_t new_size, const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a> strategy)</td></tr>
<tr class="memdesc:gaf8496139e385d0f5369307ebca30bf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory with safety checks using the specified strategy.  <br /></td></tr>
<tr class="separator:gaf8496139e385d0f5369307ebca30bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f580f9ee49f663360ac5ba6a727bc3" id="r_ga74f580f9ee49f663360ac5ba6a727bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___libmemalloc.html#ga74f580f9ee49f663360ac5ba6a727bc3">MEM_free</a> (void *const ptr)</td></tr>
<tr class="memdesc:ga74f580f9ee49f663360ac5ba6a727bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases allocated memory back to the heap.  <br /></td></tr>
<tr class="separator:ga74f580f9ee49f663360ac5ba6a727bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab03aa1c6c4ec332b91c26b47f2cddfcf" id="r_ab03aa1c6c4ec332b91c26b47f2cddfcf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmem__allocator__t.html">mem_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#ab03aa1c6c4ec332b91c26b47f2cddfcf">g_allocator</a></td></tr>
<tr class="memdesc:ab03aa1c6c4ec332b91c26b47f2cddfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process-wide default allocator instance.  <br /></td></tr>
<tr class="separator:ab03aa1c6c4ec332b91c26b47f2cddfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330cb2ec9f929baacb8527b53084d684" id="r_a330cb2ec9f929baacb8527b53084d684"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libmemalloc_8c.html#a330cb2ec9f929baacb8527b53084d684">g_allocator_inited</a> = false</td></tr>
<tr class="memdesc:a330cb2ec9f929baacb8527b53084d684"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-time initialization guard for <code>g_allocator</code>.  <br /></td></tr>
<tr class="separator:a330cb2ec9f929baacb8527b53084d684"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core memory management components for libmemalloc. </p>
<p>Implements memory allocator with advanced features:</p><ul>
<li>Architecture-specific stack allocation (alloca)</li>
<li>Garbage collection (mark &amp; sweep)</li>
<li>Block validation with magic numbers/canaries</li>
<li>Multiple allocation strategies (First/Best/Next Fit)</li>
</ul>
<dl class="section version"><dt>Version</dt><dd>v3.0.00 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28.09.2025 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Rafael V. Volkmer <a href="#" onclick="location.href='mai'+'lto:'+'raf'+'ae'+'l.v'+'.v'+'olk'+'me'+'r@g'+'ma'+'il.'+'co'+'m'; return false;">rafae<span class="obfuscator">.nosp@m.</span>l.v.<span class="obfuscator">.nosp@m.</span>volkm<span class="obfuscator">.nosp@m.</span>er@g<span class="obfuscator">.nosp@m.</span>mail.<span class="obfuscator">.nosp@m.</span>com</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2ddd2aeacc155dcd57ad9f7ed7199d9f" name="a2ddd2aeacc155dcd57ad9f7ed7199d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddd2aeacc155dcd57ad9f7ed7199d9f">&#9670;&#160;</a></span>BYTES_PER_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTES_PER_CLASS&#160;&#160;&#160;(uint8_t)(128U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed byte allocation per classification unit. </p>
<p>Defines the number of bytes assigned to each classification category. Ensures memory alignment and efficient block processing in data structures. </p>

</div>
</div>
<a id="af89f60b07247176687889ade776c8e10" name="af89f60b07247176687889ade776c8e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89f60b07247176687889ade776c8e10">&#9670;&#160;</a></span>CACHE_LINE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_LINE_SIZE&#160;&#160;&#160;(uint8_t)(64U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the CPU cache line in bytes. </p>
<p>This constant defines the cache-line size used for prefetching and alignment optimizations, ensuring memory accesses align to hardware cache boundaries for maximum performance and correctness on platforms with strict alignment requirements. </p>

</div>
</div>
<a id="a8acceb8a32aeb665817bcac0ae976c3e" name="a8acceb8a32aeb665817bcac0ae976c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acceb8a32aeb665817bcac0ae976c3e">&#9670;&#160;</a></span>DEFAULT_NUM_BINS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_NUM_BINS&#160;&#160;&#160;(uint8_t)(10U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default number of size classes (bins) for free lists. </p>
<p>Defines how many size categories (bins) the allocator will maintain for managing free memory blocks. This value affects allocation speed and fragmentation behavior. </p>

</div>
</div>
<a id="a0b87e0d3bf5853bcbb0b66a7c48fdc05" name="a0b87e0d3bf5853bcbb0b66a7c48fdc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b87e0d3bf5853bcbb0b66a7c48fdc05">&#9670;&#160;</a></span>LOG_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL&#160;&#160;&#160;<a class="el" href="group___logs.html#gga98121d38a8cf3daf5246a349f912ca1da69dacb1837e1e37c6ed34cc2ee1d8848">LOG_LEVEL_NONE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logging verbosity threshold for this module. </p>
<p>Sets the minimum severity of log messages that will be compiled into this translation unit. Only log calls at or below the specified level are enabled:</p><ul>
<li>LOG_LEVEL_NONE (0): disable all logging</li>
<li>LOG_LEVEL_ERROR (1): errors only</li>
<li>LOG_LEVEL_WARNING (2): warnings and errors</li>
<li>LOG_LEVEL_INFO (3): info, warnings, and errors</li>
<li>LOG_LEVEL_DEBUG (4): debug, info, warnings, and errors </li>
</ul>

</div>
</div>
<a id="ac1f29ba54415975a2fa23e276fdf8a0f" name="ac1f29ba54415975a2fa23e276fdf8a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f29ba54415975a2fa23e276fdf8a0f">&#9670;&#160;</a></span>MIN_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_BLOCK_SIZE&#160;&#160;&#160;(size_t)(sizeof(<a class="el" href="structblock__header__t.html">block_header_t</a>) + ARCH_ALIGNMENT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the minimum memory block size. </p>
<p>Ensures each memory block is large enough to hold a block header and alignment padding. </p>

</div>
</div>
<a id="a2911160c515036ceb8c7470a05583ae0" name="a2911160c515036ceb8c7470a05583ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2911160c515036ceb8c7470a05583ae0">&#9670;&#160;</a></span>MMAP_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MMAP_THRESHOLD&#160;&#160;&#160;(size_t)(128U * 1024U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threshold size for using mmap-based allocation. </p>
<p>When a requested allocation size meets or exceeds this value (128 KiB), the allocator will switch from using the heap (brk/sbrk) to using mmap for more efficient large-block handling and to reduce heap fragmentation. </p>

</div>
</div>
<a id="a52c92840d7afc957a6424b6dc3cc089c" name="a52c92840d7afc957a6424b6dc3cc089c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c92840d7afc957a6424b6dc3cc089c">&#9670;&#160;</a></span>NR_OBJS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NR_OBJS&#160;&#160;&#160;(uint16_t)(1000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of iterations used to scale GC sleep duration. </p>
<p>Specifies the multiplier applied to the base GC interval (in milliseconds) to compute the actual sleep time between successive garbage-collection cycles: sleep_time = gc_interval_ms * NR_OBJS </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7d054d3a536794b662ab33075d4b9fc6" name="a7d054d3a536794b662ab33075d4b9fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d054d3a536794b662ab33075d4b9fc6">&#9670;&#160;</a></span>find_fn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">find_fn_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for functions that locate a suitable free block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context in which to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Total size requested (including header and canary). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>Address of pointer to store the found block header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1eb9992270df4add51303b37ef81a93" name="ae1eb9992270df4add51303b37ef81a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1eb9992270df4add51303b37ef81a93">&#9670;&#160;</a></span>MEM_allocatorInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_allocatorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the memory allocator and its internal structures. </p>
<p>This function prepares the allocator’s heap by:</p><ul>
<li>Reading and aligning the initial program break to ARCH_ALIGNMENT.</li>
<li>Allocating the arena array and free‐list bins via <a class="el" href="libmemalloc_8c.html#a429b6c3c4d5bc23814ec213f757471b5" title="Expands the user heap by a specified increment.">MEM_growUserHeap()</a>.</li>
<li>Zeroing out the free‐list bins.</li>
<li>Initializing the allocator fields (heap_start, heap_end, free_lists).</li>
<li>Setting up the garbage‐collector thread state and its mutex/cond.</li>
<li>Capturing the current thread’s stack bounds via <a class="el" href="libmemalloc_8c.html#a05ca3438779df1a875f5d8d55f112f2a" title="Query and record the bounding addresses of a thread’s stack.">MEM_stackBounds()</a>.</li>
<li>(If under Valgrind) creating a mempool for the allocator.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to a <a class="el" href="structmem__allocator__t.html" title="Manages dynamic memory allocation.">mem_allocator_t</a> instance to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code indicating initialization result.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Allocator initialized successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>Invalid <code>allocator</code> pointer. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Heap alignment or arena/bin allocation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00eae0e01c539537bb9273c5362f9190" name="a00eae0e01c539537bb9273c5362f9190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00eae0e01c539537bb9273c5362f9190">&#9670;&#160;</a></span>MEM_allocOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * MEM_allocOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a>&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory using the specified strategy. </p>
<p>This function attempts to allocate at least <code>size</code> bytes of user data by choosing between heap‐based allocation (via free‐lists and optional heap growth) or mmap (for large requests &gt; MMAP_THRESHOLD). It uses the given <code>strategy</code> (FIRST_FIT, NEXT_FIT, BEST_FIT) to locate a free block, grows the heap if necessary, splits a larger block to fit exactly, and records debugging metadata (source file, line). For mmap allocations it rounds up to page size and tracks the region in the allocator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>Source file name for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Source line number for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>Allocation strategy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the start of the allocated user region (just past the internal header) on success; an error‐encoded pointer (via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a>) on failure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ptr</td><td>Valid user pointer on success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL or <code>size</code> is zero. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Out of memory: heap grow failed, no free block found, or internal metadata allocation (e.g. <a class="el" href="structmmap__t.html" title="Tracks memory-mapped regions for large allocations.">mmap_t</a> node) failed. </td></tr>
    <tr><td class="paramname">-EIO</td><td>mmap() I/O error for large allocations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a83d9d342786df02d60e0e5f2c75ffc" name="a2a83d9d342786df02d60e0e5f2c75ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a83d9d342786df02d60e0e5f2c75ffc">&#9670;&#160;</a></span>MEM_callocOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * MEM_callocOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a>&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and zero‐initializes memory. </p>
<p>This function behaves like calloc(), allocating at least <code>size</code> bytes of zeroed memory via <a class="el" href="libmemalloc_8c.html#a00eae0e01c539537bb9273c5362f9190" title="Allocates memory using the specified strategy.">MEM_allocOp()</a> and then setting all bytes to zero. It records debugging metadata (source file, line) and uses the given <code>strategy</code> for allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the <a class="el" href="structmem__allocator__t.html" title="Manages dynamic memory allocation.">mem_allocator_t</a> context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>Source file name for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Source line number for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>Allocation strategy to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the start of the allocated zeroed region; an error‐encoded pointer via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a> on failure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ptr</td><td>Valid pointer to <code>size</code> bytes of zeroed memory. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL or <code>size</code> is zero. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Out of memory: allocation failed. </td></tr>
    <tr><td class="paramname">-EIO</td><td>I/O error for large mmap‐based allocations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ff4096f96a8b1fb66f4dc035f6e3373" name="a0ff4096f96a8b1fb66f4dc035f6e3373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff4096f96a8b1fb66f4dc035f6e3373">&#9670;&#160;</a></span>MEM_findBestFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_findBestFit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> **&#160;</td>
          <td class="paramname"><em>best_fit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the smallest suitable free memory block in size‐class lists (BEST_FIT). </p>
<p>This function computes the starting size class for the requested <code>size</code> via <a class="el" href="libmemalloc_8c.html#afce3c776f36dbcd4df3f257d425d5c16" title="Calculates the size class index for a requested memory size.">MEM_getSizeClass()</a>, then scans each free‐list from that class upward. It validates each candidate with <a class="el" href="libmemalloc_8c.html#ac20a9b9d50b0108e6dc6571e30ad99c2" title="Validates the integrity and boundaries of a memory block.">MEM_validateBlock()</a> and tracks the smallest free block that is large enough. Once a block in any class is chosen, the search stops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Requested allocation size in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best_fit</td><td>On success, set to the pointer of the free block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Suitable block found successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>best_fit</code> is NULL. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Size calculation failed or no suitable block found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1c21ef197030ad5077e1438229ecf7b" name="ad1c21ef197030ad5077e1438229ecf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c21ef197030ad5077e1438229ecf7b">&#9670;&#160;</a></span>MEM_findFirstFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_findFirstFit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> **&#160;</td>
          <td class="paramname"><em>fit_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the first suitable free memory block in size‐class lists. </p>
<p>This function computes the starting size class for the requested <code>size</code> via <a class="el" href="libmemalloc_8c.html#afce3c776f36dbcd4df3f257d425d5c16" title="Calculates the size class index for a requested memory size.">MEM_getSizeClass()</a>, then scans each free‐list from that class upward. For each candidate block, it calls <a class="el" href="libmemalloc_8c.html#ac20a9b9d50b0108e6dc6571e30ad99c2" title="Validates the integrity and boundaries of a memory block.">MEM_validateBlock()</a> to ensure integrity, and returns the first block that is marked free and large enough. The found block pointer is stored in <code>fit_block</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Requested allocation size in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fit_block</td><td>On success, set to the pointer of a suitable free block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Suitable block found successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>fit_block</code> are NULL; </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Size calculation failed or no suitable block found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d5a3d1efacb5148c598825eb0c69708" name="a3d5a3d1efacb5148c598825eb0c69708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5a3d1efacb5148c598825eb0c69708">&#9670;&#160;</a></span>MEM_findNextFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_findNextFit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> **&#160;</td>
          <td class="paramname"><em>fit_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the next suitable free memory block using the NEXT_FIT strategy starting from the last allocated position. </p>
<p>This function attempts to find a free block of at least <code>size</code> bytes by scanning the heap starting at allocator-&gt;last_allocated. If last_allocated is NULL, not free, or corrupted, it falls back to First-Fit. It wraps around to the heap start if needed, stopping once it returns to the start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Requested allocation size in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fit_block</td><td>Pointer to store the address of the found block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Suitable block found and fit_block set. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>fit_block</code> is NULL. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>No suitable block found in heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd60695c4e1065292ab9af0ec7da5a0" name="a8dd60695c4e1065292ab9af0ec7da5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd60695c4e1065292ab9af0ec7da5a0">&#9670;&#160;</a></span>MEM_freeOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_freeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases allocated memory back to the heap. </p>
<p>This function frees a pointer previously returned by <a class="el" href="libmemalloc_8c.html#a00eae0e01c539537bb9273c5362f9190" title="Allocates memory using the specified strategy.">MEM_allocOp()</a>. It supports both heap‐based and mmap‐based allocations:</p><ul>
<li>For mmap regions, it delegates to <a class="el" href="libmemalloc_8c.html#af1b841111a1506abe32e887ca96b883c" title="Unmaps a previously mapped memory region and removes its metadata entry from the allocator’s mmap lis...">MEM_mapFree()</a> to unmap and remove metadata.</li>
<li>For heap blocks, it validates the block, checks for double frees, marks the block free, merges with adjacent free blocks, and reinserts the merged block into the free list. If the freed block lies at the current heap end, it shrinks the heap via <a class="el" href="libmemalloc_8c.html#ae5805f4c67ac5fe3b63f8e26041ee0aa" title="Invokes sbrk-like behavior by moving the program break.">MEM_sbrk()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to memory to free. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>Source file name for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Source line number for debugging metadata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Memory freed (and heap possibly shrunk) successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>ptr</code> is NULL, <code>ptr</code> not found in <code>allocator</code>, or double free detected. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>munmap() failed when freeing an mmap region. </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>Block lies outside heap and mmap regions. </td></tr>
    <tr><td class="paramname">-EPROTO</td><td>Header canary mismatch (block corrupted). </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>Data canary mismatch (buffer overrun detected). </td></tr>
    <tr><td class="paramname">-EFBIG</td><td>Block size extends past heap end. </td></tr>
    <tr><td class="paramname">rer&lt;0</td><td>Errors returned by <a class="el" href="libmemalloc_8c.html#ac20a9b9d50b0108e6dc6571e30ad99c2" title="Validates the integrity and boundaries of a memory block.">MEM_validateBlock()</a>, <a class="el" href="libmemalloc_8c.html#a12ec011b3d73b77babe83930fa7200f0" title="Removes a block from its free list.">MEM_removeFreeBlock()</a>, <a class="el" href="libmemalloc_8c.html#a4b1829256c0f068782ccab6c9f95c826" title="Merges adjacent free memory blocks.">MEM_mergeBlocks()</a>, or <a class="el" href="libmemalloc_8c.html#ae5d23c9024583a7682a5857f59523d6e" title="Inserts a block into the appropriate free list based on its size.">MEM_insertFreeBlock()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce3c776f36dbcd4df3f257d425d5c16" name="afce3c776f36dbcd4df3f257d425d5c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce3c776f36dbcd4df3f257d425d5c16">&#9670;&#160;</a></span>MEM_getSizeClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_getSizeClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the size class index for a requested memory size. </p>
<p>This function determines which size class the given allocation request belongs to by dividing the requested <code>size</code> by BYTES_PER_CLASS (rounding up). If the computed index exceeds the maximum available class, it will be clamped to the highest class and a warning emitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Requested memory size in bytes (must be &gt; 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns a non-negative integer size class index; on failure, returns a negative error code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ret&gt;0</td><td>Valid size class index. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL, or <code>size</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429b6c3c4d5bc23814ec213f757471b5" name="a429b6c3c4d5bc23814ec213f757471b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429b6c3c4d5bc23814ec213f757471b5">&#9670;&#160;</a></span>MEM_growUserHeap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * MEM_growUserHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const intptr_t&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands the user heap by a specified increment. </p>
<p>This function moves the program break by <code>inc</code> bytes via <a class="el" href="libmemalloc_8c.html#ae5805f4c67ac5fe3b63f8e26041ee0aa" title="Invokes sbrk-like behavior by moving the program break.">MEM_sbrk()</a>, zeroes the newly allocated region, updates the allocator’s heap_end, and initializes a <a class="el" href="structblock__header__t.html" title="Represents the header for a memory block.">block_header_t</a> at the start of the new region to record its size, mark it as allocated, and set its free flag to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inc</td><td>Signed number of bytes to grow (or shrink) the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the previous program break (start of new region) on success; an error-encoded pointer (via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a>) on failure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(ret&gt;=0)</td><td>Previous heap end address (new region start). </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Heap expansion failed (out of memory). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d23c9024583a7682a5857f59523d6e" name="ae5d23c9024583a7682a5857f59523d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d23c9024583a7682a5857f59523d6e">&#9670;&#160;</a></span>MEM_insertFreeBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_insertFreeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> *const&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a block into the appropriate free list based on its size. </p>
<p>This function computes the size class index for the given <code>block</code> by calling <a class="el" href="libmemalloc_8c.html#afce3c776f36dbcd4df3f257d425d5c16" title="Calculates the size class index for a requested memory size.">MEM_getSizeClass()</a>, then pushes the block onto the head of that free list within the allocator. It updates both forward and backward links to maintain the doubly‐linked list of free blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to the block header to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td><code>block</code> successfully inserted. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>block</code> is NULL. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Size class calculation failed (request too large). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302a9aebc59213a1fdca5ef62cfd3eef" name="a302a9aebc59213a1fdca5ef62cfd3eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302a9aebc59213a1fdca5ef62cfd3eef">&#9670;&#160;</a></span>MEM_mapAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * MEM_mapAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a page-aligned memory region via mmap and registers it in the allocator’s mmap list for later freeing. </p>
<p>This function rounds up <code>total_size</code> to a multiple of the system page size, invokes mmap() to obtain an anonymous read/write region, then allocates an <a class="el" href="structmmap__t.html" title="Tracks memory-mapped regions for large allocations.">mmap_t</a> metadata node via <a class="el" href="libmemalloc_8c.html#a00eae0e01c539537bb9273c5362f9190" title="Allocates memory using the specified strategy.">MEM_allocOp()</a> and links it into allocator-&gt;mmap_list. It initializes a <a class="el" href="structblock__header__t.html" title="Represents the header for a memory block.">block_header_t</a> and trailing canary in the mapped region to integrate with the allocator’s debugging and GC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total_size</td><td>Number of bytes requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the address of the mapped region. On failure, returns an error-encoded pointer (via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a>).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ret!=MAP_FAILED</td><td>Address of the mapped region. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL. </td></tr>
    <tr><td class="paramname">-EIO</td><td>mmap() failed. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Allocation of <a class="el" href="structmmap__t.html" title="Tracks memory-mapped regions for large allocations.">mmap_t</a> metadata failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b841111a1506abe32e887ca96b883c" name="af1b841111a1506abe32e887ca96b883c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b841111a1506abe32e887ca96b883c">&#9670;&#160;</a></span>MEM_mapFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_mapFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps a previously mapped memory region and removes its metadata entry from the allocator’s mmap list. </p>
<p>This function searches the allocator’s mmap_list for an entry matching <code>addr</code>, calls munmap() to unmap the region, unlinks the corresponding <a class="el" href="structmmap__t.html" title="Tracks memory-mapped regions for large allocations.">mmap_t</a> metadata node, and frees it via <a class="el" href="libmemalloc_8c.html#a8dd60695c4e1065292ab9af0ec7da5a0" title="Releases allocated memory back to the heap.">MEM_freeOp()</a>. Errors during munmap are returned; if metadata freeing fails, an error is logged but success is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of the memory region to unmap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Region unmapped and metadata entry removed. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> / <code>addr</code> is NULL, or not found in list. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>munmap() failed to unmap the region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1829256c0f068782ccab6c9f95c826" name="a4b1829256c0f068782ccab6c9f95c826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1829256c0f068782ccab6c9f95c826">&#9670;&#160;</a></span>MEM_mergeBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_mergeBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges adjacent free memory blocks. </p>
<p>This function removes the specified <code>block</code> from its free list, then checks its immediate neighbor blocks in memory. If the next block is free and valid, it unlinks and combines it with <code>block</code>, updating size, links, and trailing canary. It then checks the previous block; if it is also free and valid, it merges <code>block</code> into the previous block. Finally, the resulting merged block is reinserted into the appropriate free list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to the free block header to merge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Blocks merged (or single block reinserted) successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>block</code> is NULL. </td></tr>
    <tr><td class="paramname">ret&lt;0</td><td>Returned by <a class="el" href="libmemalloc_8c.html#a12ec011b3d73b77babe83930fa7200f0" title="Removes a block from its free list.">MEM_removeFreeBlock()</a>, <a class="el" href="libmemalloc_8c.html#ac20a9b9d50b0108e6dc6571e30ad99c2" title="Validates the integrity and boundaries of a memory block.">MEM_validateBlock()</a>, <a class="el" href="libmemalloc_8c.html#ae5d23c9024583a7682a5857f59523d6e" title="Inserts a block into the appropriate free list based on its size.">MEM_insertFreeBlock()</a>, or munmap() in inner calls indicating the specific failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06c4368d312a9014619535dedfdecda2" name="a06c4368d312a9014619535dedfdecda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c4368d312a9014619535dedfdecda2">&#9670;&#160;</a></span>MEM_reallocOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * MEM_reallocOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___libmemalloc.html#ga36d2f4c096864df4566ad4ccbf9f1cc8">allocation_strategy_t</a>&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocates memory with safety checks. </p>
<p>This function resizes an existing allocation to <code>new_size</code> bytes:</p><ul>
<li>If <code>ptr</code> is NULL, behaves like malloc().</li>
<li>If the existing block is already large enough, returns the same pointer.</li>
<li>Otherwise, allocates a new block with the specified <code>strategy</code>, copies the lesser of old and new sizes, frees the old block, and returns the new pointer.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the block to resize, or NULL to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>New requested size in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>Source file name for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Source line number for debugging metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strategy</td><td>Allocation strategy to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the reallocated memory region (which may be the same as <code>ptr</code>) on success; an error-encoded pointer (via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a>) on failure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ptr</td><td>Valid pointer to a block of at least <code>new_size</code> bytes. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> is NULL, <code>new_size</code> is zero. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Out of memory (allocation or free failure). </td></tr>
    <tr><td class="paramname">-EIO</td><td>I/O error for large mmap-based allocations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12ec011b3d73b77babe83930fa7200f0" name="a12ec011b3d73b77babe83930fa7200f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ec011b3d73b77babe83930fa7200f0">&#9670;&#160;</a></span>MEM_removeFreeBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_removeFreeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> *const&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a block from its free list. </p>
<p>This function unlinks the specified <code>block</code> from the free list corresponding to its size class within the allocator. It computes the size‐class index via <a class="el" href="libmemalloc_8c.html#afce3c776f36dbcd4df3f257d425d5c16" title="Calculates the size class index for a requested memory size.">MEM_getSizeClass()</a>, validates parameters, then adjusts the neighboring blocks’ fl_next and fl_prev pointers (or the list head) to remove <code>block</code>. The block’s own fl_next and fl_prev are then cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Block header to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Block removed successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>block</code> is NULL. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Size‐class calculation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5805f4c67ac5fe3b63f8e26041ee0aa" name="ae5805f4c67ac5fe3b63f8e26041ee0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5805f4c67ac5fe3b63f8e26041ee0aa">&#9670;&#160;</a></span>MEM_sbrk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * MEM_sbrk </td>
          <td>(</td>
          <td class="paramtype">const intptr_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes sbrk-like behavior by moving the program break. </p>
<p>This function reads the current program break, attempts to move it by the signed offset <code>increment</code> via sbrk(), and returns the original break on success. If any call to sbrk() or reading the break fails, it encodes the negative errno into a pointer via PTR_ERR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">increment</td><td>Signed offset in bytes to move the program break: positive to grow, negative to shrink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Original program break address on success; an error-encoded pointer (via <a class="el" href="group___libmemalloc.html#ga10d2d9517329749b0a3d54cf95adc491" title="Encodes a negative error code as an error pointer.">PTR_ERR()</a>) on failure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ret&gt;-1</td><td>Previous break on success. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Failed to read or adjust the break. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a027e298e9296c2bbbf6fc80a95afc" name="a09a027e298e9296c2bbbf6fc80a95afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a027e298e9296c2bbbf6fc80a95afc">&#9670;&#160;</a></span>MEM_splitBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_splitBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> *const&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>req_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a memory block into allocated and free portions. </p>
<p>This function takes an existing free <code>block</code> and a requested allocation size <code>req_size</code>, and divides the block into:</p><ul>
<li>an allocated portion of size aligned up to <a class="el" href="group___libmemalloc.html#ga6fe2b41e8a49eb133afc79eadf03a289" title="Aligns a given value to the nearest memory boundary.">ALIGN(req_size)</a> plus header and canary, marked as used;</li>
<li>a remaining free portion (if its size ≥ MIN_BLOCK_SIZE) inserted back into the appropriate free list. If the leftover space would be too small (&lt; MIN_BLOCK_SIZE), the entire block is allocated without splitting.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the <a class="el" href="structmem__allocator__t.html" title="Manages dynamic memory allocation.">mem_allocator_t</a> context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to the <a class="el" href="structblock__header__t.html" title="Represents the header for a memory block.">block_header_t</a> to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req_size</td><td>Requested allocation size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Block split (or fully allocated) successfully. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>nvalid <code>allocator</code> or <code>block</code> pointer. </td></tr>
    <tr><td class="paramname">-EPROTO</td><td>Header canary mismatch (block corrupted). </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>Data canary mismatch (buffer overflow detected). </td></tr>
    <tr><td class="paramname">-EFBIG</td><td>Block’s size would extend past heap end. </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>Block lies outside heap or mmap regions. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Failed to insert the new free remainder block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the remaining space after splitting would be less than MIN_BLOCK_SIZE, this function allocates the entire block no split) and removes it from its free list. </dd></dl>

</div>
</div>
<a id="a05ca3438779df1a875f5d8d55f112f2a" name="a05ca3438779df1a875f5d8d55f112f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ca3438779df1a875f5d8d55f112f2a">&#9670;&#160;</a></span>MEM_stackBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_stackBounds </td>
          <td>(</td>
          <td class="paramtype">const pthread_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query and record the bounding addresses of a thread’s stack. </p>
<p>This function retrieves the stack base address, total stack size, and guard size for the specified thread, then computes the usable stack bounds within the allocator object, taking into account whether the stack grows up or down in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The thread identifier whose stack to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator object where stack_bottom and stack_top will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td>Stack bounds successfully recorded. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> was NULL. </td></tr>
    <tr><td class="paramname">ret&gt;0</td><td>Error code from one of the pthread or system calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dd55c30122e42f8dfb40e78861486be" name="a0dd55c30122e42f8dfb40e78861486be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd55c30122e42f8dfb40e78861486be">&#9670;&#160;</a></span>MEM_stackGrowsDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MEM_stackGrowsDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine at runtime whether the stack grows downward. </p>
<p>This function places two volatile local variables on the stack and compares their addresses to infer the growth direction:</p><ul>
<li>If &amp;addr_1 &lt; &amp;addr_0, the stack grows toward lower addresses.</li>
<li>Otherwise, it grows toward higher addresses.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if stack grows down (higher addresses → lower), false if it grows up (lower addresses → higher)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Stack grows downward (newer frames at lower addresses) </td></tr>
    <tr><td class="paramname">false</td><td>Stack grows upward (newer frames at higher addresses) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac20a9b9d50b0108e6dc6571e30ad99c2" name="ac20a9b9d50b0108e6dc6571e30ad99c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20a9b9d50b0108e6dc6571e30ad99c2">&#9670;&#160;</a></span>MEM_validateBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MEM_validateBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__allocator__t.html">mem_allocator_t</a> *const&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblock__header__t.html">block_header_t</a> *const&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the integrity and boundaries of a memory block. </p>
<p>This function ensures that the specified <code>block</code> lies within the allocator’s heap or one of its mmap regions, that its header canary matches the expected magic value to detect metadata corruption, that its data canary is intact to catch buffer overruns, and that the block’s size does not extend past the heap’s end. On any failure, an appropriate negative errno is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to the allocator context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to the block header to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer status code.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXIT_SUCCESS</td><td><code>block</code> is valid. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td><code>allocator</code> or <code>block</code> pointer is NULL. </td></tr>
    <tr><td class="paramname">-EFAULT</td><td><code>block</code> lies outside heap and mmap regions. </td></tr>
    <tr><td class="paramname">-EPROTO</td><td><code>block</code> canary does not match expected value. </td></tr>
    <tr><td class="paramname">-EFBIG</td><td><code>block</code> size causes it to extend past heap end. </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td><code>block</code> canary indicates buffer overflow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab03aa1c6c4ec332b91c26b47f2cddfcf" name="ab03aa1c6c4ec332b91c26b47f2cddfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03aa1c6c4ec332b91c26b47f2cddfcf">&#9670;&#160;</a></span>g_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">g_allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process-wide default allocator instance. </p>
<p>Statically allocated allocator used when the API is called without an explicit <code><a class="el" href="structmem__allocator__t.html" title="Manages dynamic memory allocation.">mem_allocator_t</a></code> handle. This instance is initialized exactly once (see <code>g_allocator_inited</code>) and then reused for all subsequent allocation requests routed through the “global” path.</p>
<dl class="section note"><dt>Note</dt><dd>File-scope <code>static</code> grants internal linkage: the symbol is private to this translation unit.</dd></dl>
<dl class="section user"><dt>Thread-Safety</dt><dd>Initialization must be synchronized so only one thread performs it (e.g., via <code>pthread_once</code> or equivalent). Normal allocator operations should rely on the allocator’s internal locking.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="libmemalloc_8c.html#ae1eb9992270df4add51303b37ef81a93" title="Initializes the memory allocator and its internal structures.">MEM_allocatorInit()</a>, <a class="el" href="libmemalloc_8c.html#a00eae0e01c539537bb9273c5362f9190" title="Allocates memory using the specified strategy.">MEM_allocOp()</a>, <a class="el" href="group___libmemalloc.html#ga74f580f9ee49f663360ac5ba6a727bc3" title="Releases allocated memory back to the heap.">MEM_free()</a>, <a class="el" href="group___libmemalloc.html#gaf8496139e385d0f5369307ebca30bf17" title="Reallocates memory with safety checks using the specified strategy.">MEM_realloc()</a> </dd></dl>

</div>
</div>
<a id="a330cb2ec9f929baacb8527b53084d684" name="a330cb2ec9f929baacb8527b53084d684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330cb2ec9f929baacb8527b53084d684">&#9670;&#160;</a></span>g_allocator_inited</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">g_allocator_inited = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-time initialization guard for <code>g_allocator</code>. </p>
<p>Boolean-like flag controlling lazy init of the global allocator. A value of 0 means “not initialized”; 1 means “initialized”. It should be set to 1 only after a successful call to <code>MEM_allocatorInit(&amp;g_allocator)</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This flag is a plain <code>int</code> and is not atomic. In multi-threaded contexts, protect initialization with proper synchronization (e.g., <code>pthread_once</code>, a mutex, or atomic CAS) to avoid races. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
SPDX-FileCopyrightText: 2024-2025 Rafael V. Volkmer <rafael.v.volkmer@gmail.com>
SPDX-License-Identifier: MIT
-->
<!-- Included at the end of all pages -->
<link rel="stylesheet" href="coverage-pill.css" />
<script src="coverage-link.js"></script>
